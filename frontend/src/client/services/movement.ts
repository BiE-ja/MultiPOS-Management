/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Tantana - Boutik
 * OpenAPI spec version: 0.1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  MovementProductTrackParams,
  StockMovementCreate,
  StockMovementRead
} from '../schemas';

import { customAxios } from '../custom-client';





/**
 * @summary Create
 */
export const movementCreate = (
    stockMovementCreate: StockMovementCreate,
 signal?: AbortSignal
) => {
      
      
      return customAxios<StockMovementRead>(
      {url: `/api/v0.1/stock/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: stockMovementCreate, signal
    },
      );
    }
  


export const getMovementCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof movementCreate>>, TError,{data: StockMovementCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof movementCreate>>, TError,{data: StockMovementCreate}, TContext> => {

const mutationKey = ['movementCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof movementCreate>>, {data: StockMovementCreate}> = (props) => {
          const {data} = props ?? {};

          return  movementCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MovementCreateMutationResult = NonNullable<Awaited<ReturnType<typeof movementCreate>>>
    export type MovementCreateMutationBody = StockMovementCreate
    export type MovementCreateMutationError = HTTPValidationError

    /**
 * @summary Create
 */
export const useMovementCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof movementCreate>>, TError,{data: StockMovementCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof movementCreate>>,
        TError,
        {data: StockMovementCreate},
        TContext
      > => {

      const mutationOptions = getMovementCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Read
 */
export const movementRead = (
    movementId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<StockMovementRead>(
      {url: `/api/v0.1/stock/${movementId}`, method: 'GET', signal
    },
      );
    }
  

export const getMovementReadQueryKey = (movementId?: string,) => {
    return [`/api/v0.1/stock/${movementId}`] as const;
    }

    
export const getMovementReadInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof movementRead>>>, TError = HTTPValidationError>(movementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMovementReadQueryKey(movementId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof movementRead>>> = ({ signal }) => movementRead(movementId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(movementId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MovementReadInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof movementRead>>>
export type MovementReadInfiniteQueryError = HTTPValidationError


export function useMovementReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementRead>>>, TError = HTTPValidationError>(
 movementId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementRead>>,
          TError,
          Awaited<ReturnType<typeof movementRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementRead>>>, TError = HTTPValidationError>(
 movementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementRead>>,
          TError,
          Awaited<ReturnType<typeof movementRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementRead>>>, TError = HTTPValidationError>(
 movementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read
 */

export function useMovementReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementRead>>>, TError = HTTPValidationError>(
 movementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMovementReadInfiniteQueryOptions(movementId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getMovementReadQueryOptions = <TData = Awaited<ReturnType<typeof movementRead>>, TError = HTTPValidationError>(movementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMovementReadQueryKey(movementId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof movementRead>>> = ({ signal }) => movementRead(movementId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(movementId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MovementReadQueryResult = NonNullable<Awaited<ReturnType<typeof movementRead>>>
export type MovementReadQueryError = HTTPValidationError


export function useMovementRead<TData = Awaited<ReturnType<typeof movementRead>>, TError = HTTPValidationError>(
 movementId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementRead>>,
          TError,
          Awaited<ReturnType<typeof movementRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementRead<TData = Awaited<ReturnType<typeof movementRead>>, TError = HTTPValidationError>(
 movementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementRead>>,
          TError,
          Awaited<ReturnType<typeof movementRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementRead<TData = Awaited<ReturnType<typeof movementRead>>, TError = HTTPValidationError>(
 movementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read
 */

export function useMovementRead<TData = Awaited<ReturnType<typeof movementRead>>, TError = HTTPValidationError>(
 movementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementRead>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMovementReadQueryOptions(movementId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Cancel
 */
export const movementCancel = (
    movementId: string,
 ) => {
      
      
      return customAxios<null>(
      {url: `/api/v0.1/stock/${movementId}`, method: 'DELETE'
    },
      );
    }
  


export const getMovementCancelMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof movementCancel>>, TError,{movementId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof movementCancel>>, TError,{movementId: string}, TContext> => {

const mutationKey = ['movementCancel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof movementCancel>>, {movementId: string}> = (props) => {
          const {movementId} = props ?? {};

          return  movementCancel(movementId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MovementCancelMutationResult = NonNullable<Awaited<ReturnType<typeof movementCancel>>>
    
    export type MovementCancelMutationError = HTTPValidationError

    /**
 * @summary Cancel
 */
export const useMovementCancel = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof movementCancel>>, TError,{movementId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof movementCancel>>,
        TError,
        {movementId: string},
        TContext
      > => {

      const mutationOptions = getMovementCancelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Product Track
 */
export const movementProductTrack = (
    productId: string,
    params: MovementProductTrackParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<StockMovementRead[]>(
      {url: `/api/v0.1/stock/product/${productId}/history`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getMovementProductTrackQueryKey = (productId?: string,
    params?: MovementProductTrackParams,) => {
    return [`/api/v0.1/stock/product/${productId}/history`, ...(params ? [params]: [])] as const;
    }

    
export const getMovementProductTrackInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof movementProductTrack>>>, TError = HTTPValidationError>(productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMovementProductTrackQueryKey(productId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof movementProductTrack>>> = ({ signal }) => movementProductTrack(productId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MovementProductTrackInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof movementProductTrack>>>
export type MovementProductTrackInfiniteQueryError = HTTPValidationError


export function useMovementProductTrackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementProductTrack>>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementProductTrack>>,
          TError,
          Awaited<ReturnType<typeof movementProductTrack>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementProductTrackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementProductTrack>>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementProductTrack>>,
          TError,
          Awaited<ReturnType<typeof movementProductTrack>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementProductTrackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementProductTrack>>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Product Track
 */

export function useMovementProductTrackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof movementProductTrack>>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMovementProductTrackInfiniteQueryOptions(productId,params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getMovementProductTrackQueryOptions = <TData = Awaited<ReturnType<typeof movementProductTrack>>, TError = HTTPValidationError>(productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMovementProductTrackQueryKey(productId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof movementProductTrack>>> = ({ signal }) => movementProductTrack(productId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MovementProductTrackQueryResult = NonNullable<Awaited<ReturnType<typeof movementProductTrack>>>
export type MovementProductTrackQueryError = HTTPValidationError


export function useMovementProductTrack<TData = Awaited<ReturnType<typeof movementProductTrack>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementProductTrack>>,
          TError,
          Awaited<ReturnType<typeof movementProductTrack>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementProductTrack<TData = Awaited<ReturnType<typeof movementProductTrack>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof movementProductTrack>>,
          TError,
          Awaited<ReturnType<typeof movementProductTrack>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMovementProductTrack<TData = Awaited<ReturnType<typeof movementProductTrack>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Product Track
 */

export function useMovementProductTrack<TData = Awaited<ReturnType<typeof movementProductTrack>>, TError = HTTPValidationError>(
 productId: string,
    params: MovementProductTrackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof movementProductTrack>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMovementProductTrackQueryOptions(productId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



