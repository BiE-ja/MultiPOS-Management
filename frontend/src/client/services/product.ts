/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * Tantana - Boutik
 * OpenAPI spec version: 0.1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  PriceHistoryRead,
  ProductCreate,
  ProductDashboardParams,
  ProductDashbordRead,
  ProductDeleteParams,
  ProductFetchAllForSuperuserParams,
  ProductFetchAllParams,
  ProductPriceHistoryParams,
  ProductRead,
  ProductUpdate,
  UserRead
} from '../schemas';

import { customAxios } from '../custom-client';





/**
 * @summary Create
 */
export const productCreate = (
    productCreate: ProductCreate,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ProductRead>(
      {url: `/api/v0.1/product/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productCreate, signal
    },
      );
    }
  


export const getProductCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productCreate>>, TError,{data: ProductCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof productCreate>>, TError,{data: ProductCreate}, TContext> => {

const mutationKey = ['productCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productCreate>>, {data: ProductCreate}> = (props) => {
          const {data} = props ?? {};

          return  productCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProductCreateMutationResult = NonNullable<Awaited<ReturnType<typeof productCreate>>>
    export type ProductCreateMutationBody = ProductCreate
    export type ProductCreateMutationError = HTTPValidationError

    /**
 * @summary Create
 */
export const useProductCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productCreate>>, TError,{data: ProductCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof productCreate>>,
        TError,
        {data: ProductCreate},
        TContext
      > => {

      const mutationOptions = getProductCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Read
 */
export const productRead = (
    productId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ProductRead>(
      {url: `/api/v0.1/product/${productId}`, method: 'GET', signal
    },
      );
    }
  

export const getProductReadQueryKey = (productId?: string,) => {
    return [`/api/v0.1/product/${productId}`] as const;
    }

    
export const getProductReadInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof productRead>>>, TError = HTTPValidationError>(productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductReadQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productRead>>> = ({ signal }) => productRead(productId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductReadInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof productRead>>>
export type ProductReadInfiniteQueryError = HTTPValidationError


export function useProductReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productRead>>>, TError = HTTPValidationError>(
 productId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productRead>>,
          TError,
          Awaited<ReturnType<typeof productRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productRead>>>, TError = HTTPValidationError>(
 productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productRead>>,
          TError,
          Awaited<ReturnType<typeof productRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productRead>>>, TError = HTTPValidationError>(
 productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read
 */

export function useProductReadInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productRead>>>, TError = HTTPValidationError>(
 productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductReadInfiniteQueryOptions(productId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getProductReadQueryOptions = <TData = Awaited<ReturnType<typeof productRead>>, TError = HTTPValidationError>(productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductReadQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productRead>>> = ({ signal }) => productRead(productId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductReadQueryResult = NonNullable<Awaited<ReturnType<typeof productRead>>>
export type ProductReadQueryError = HTTPValidationError


export function useProductRead<TData = Awaited<ReturnType<typeof productRead>>, TError = HTTPValidationError>(
 productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productRead>>,
          TError,
          Awaited<ReturnType<typeof productRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductRead<TData = Awaited<ReturnType<typeof productRead>>, TError = HTTPValidationError>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productRead>>,
          TError,
          Awaited<ReturnType<typeof productRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductRead<TData = Awaited<ReturnType<typeof productRead>>, TError = HTTPValidationError>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read
 */

export function useProductRead<TData = Awaited<ReturnType<typeof productRead>>, TError = HTTPValidationError>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productRead>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductReadQueryOptions(productId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update
 */
export const productUpdate = (
    productId: string,
    productUpdate: ProductUpdate,
 ) => {
      
      
      return customAxios<ProductRead>(
      {url: `/api/v0.1/product/${productId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productUpdate
    },
      );
    }
  


export const getProductUpdateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productUpdate>>, TError,{productId: string;data: ProductUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof productUpdate>>, TError,{productId: string;data: ProductUpdate}, TContext> => {

const mutationKey = ['productUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productUpdate>>, {productId: string;data: ProductUpdate}> = (props) => {
          const {productId,data} = props ?? {};

          return  productUpdate(productId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProductUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof productUpdate>>>
    export type ProductUpdateMutationBody = ProductUpdate
    export type ProductUpdateMutationError = HTTPValidationError

    /**
 * @summary Update
 */
export const useProductUpdate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productUpdate>>, TError,{productId: string;data: ProductUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof productUpdate>>,
        TError,
        {productId: string;data: ProductUpdate},
        TContext
      > => {

      const mutationOptions = getProductUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Delete
 */
export const productDelete = (
    productId: string,
    params: ProductDeleteParams,
 ) => {
      
      
      return customAxios<null>(
      {url: `/api/v0.1/product/${productId}`, method: 'DELETE',
        params
    },
      );
    }
  


export const getProductDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productDelete>>, TError,{productId: string;params: ProductDeleteParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof productDelete>>, TError,{productId: string;params: ProductDeleteParams}, TContext> => {

const mutationKey = ['productDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof productDelete>>, {productId: string;params: ProductDeleteParams}> = (props) => {
          const {productId,params} = props ?? {};

          return  productDelete(productId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProductDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof productDelete>>>
    
    export type ProductDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete
 */
export const useProductDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof productDelete>>, TError,{productId: string;params: ProductDeleteParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof productDelete>>,
        TError,
        {productId: string;params: ProductDeleteParams},
        TContext
      > => {

      const mutationOptions = getProductDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Obtain list of product of an area
 * @summary Fetch All
 */
export const productFetchAll = (
    areaId: string,
    params?: ProductFetchAllParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ProductRead[]>(
      {url: `/api/v0.1/product/list/${areaId}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getProductFetchAllQueryKey = (areaId?: string,
    params?: ProductFetchAllParams,) => {
    return [`/api/v0.1/product/list/${areaId}`, ...(params ? [params]: [])] as const;
    }

    
export const getProductFetchAllInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof productFetchAll>>>, TError = HTTPValidationError>(areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductFetchAllQueryKey(areaId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productFetchAll>>> = ({ signal }) => productFetchAll(areaId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(areaId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductFetchAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof productFetchAll>>>
export type ProductFetchAllInfiniteQueryError = HTTPValidationError


export function useProductFetchAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAll>>>, TError = HTTPValidationError>(
 areaId: string,
    params: undefined |  ProductFetchAllParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAll>>,
          TError,
          Awaited<ReturnType<typeof productFetchAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAll>>>, TError = HTTPValidationError>(
 areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAll>>,
          TError,
          Awaited<ReturnType<typeof productFetchAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAll>>>, TError = HTTPValidationError>(
 areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch All
 */

export function useProductFetchAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAll>>>, TError = HTTPValidationError>(
 areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductFetchAllInfiniteQueryOptions(areaId,params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getProductFetchAllQueryOptions = <TData = Awaited<ReturnType<typeof productFetchAll>>, TError = HTTPValidationError>(areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductFetchAllQueryKey(areaId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productFetchAll>>> = ({ signal }) => productFetchAll(areaId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(areaId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductFetchAllQueryResult = NonNullable<Awaited<ReturnType<typeof productFetchAll>>>
export type ProductFetchAllQueryError = HTTPValidationError


export function useProductFetchAll<TData = Awaited<ReturnType<typeof productFetchAll>>, TError = HTTPValidationError>(
 areaId: string,
    params: undefined |  ProductFetchAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAll>>,
          TError,
          Awaited<ReturnType<typeof productFetchAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAll<TData = Awaited<ReturnType<typeof productFetchAll>>, TError = HTTPValidationError>(
 areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAll>>,
          TError,
          Awaited<ReturnType<typeof productFetchAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAll<TData = Awaited<ReturnType<typeof productFetchAll>>, TError = HTTPValidationError>(
 areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch All
 */

export function useProductFetchAll<TData = Awaited<ReturnType<typeof productFetchAll>>, TError = HTTPValidationError>(
 areaId: string,
    params?: ProductFetchAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductFetchAllQueryOptions(areaId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Superuser can obtain list of product for one point of sale
 * @summary Fetch All For Superuser
 */
export const productFetchAllForSuperuser = (
    areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ProductRead[]>(
      {url: `/api/v0.1/product/superuser/list/${areaId}`, method: 'GET',
      headers: {'Content-Type': 'application/json', },
        params, signal
    },
      );
    }
  

export const getProductFetchAllForSuperuserQueryKey = (areaId?: string,
    userRead?: UserRead,
    params?: ProductFetchAllForSuperuserParams,) => {
    return [`/api/v0.1/product/superuser/list/${areaId}`, ...(params ? [params]: []), userRead] as const;
    }

    
export const getProductFetchAllForSuperuserInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof productFetchAllForSuperuser>>>, TError = HTTPValidationError>(areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductFetchAllForSuperuserQueryKey(areaId,userRead,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productFetchAllForSuperuser>>> = ({ signal }) => productFetchAllForSuperuser(areaId,userRead,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(areaId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductFetchAllForSuperuserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof productFetchAllForSuperuser>>>
export type ProductFetchAllForSuperuserInfiniteQueryError = HTTPValidationError


export function useProductFetchAllForSuperuserInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAllForSuperuser>>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params: undefined |  ProductFetchAllForSuperuserParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>,
          TError,
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAllForSuperuserInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAllForSuperuser>>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>,
          TError,
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAllForSuperuserInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAllForSuperuser>>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch All For Superuser
 */

export function useProductFetchAllForSuperuserInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productFetchAllForSuperuser>>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductFetchAllForSuperuserInfiniteQueryOptions(areaId,userRead,params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getProductFetchAllForSuperuserQueryOptions = <TData = Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError = HTTPValidationError>(areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductFetchAllForSuperuserQueryKey(areaId,userRead,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productFetchAllForSuperuser>>> = ({ signal }) => productFetchAllForSuperuser(areaId,userRead,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(areaId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductFetchAllForSuperuserQueryResult = NonNullable<Awaited<ReturnType<typeof productFetchAllForSuperuser>>>
export type ProductFetchAllForSuperuserQueryError = HTTPValidationError


export function useProductFetchAllForSuperuser<TData = Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params: undefined |  ProductFetchAllForSuperuserParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>,
          TError,
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAllForSuperuser<TData = Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>,
          TError,
          Awaited<ReturnType<typeof productFetchAllForSuperuser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductFetchAllForSuperuser<TData = Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch All For Superuser
 */

export function useProductFetchAllForSuperuser<TData = Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError = HTTPValidationError>(
 areaId: string,
    userRead: UserRead,
    params?: ProductFetchAllForSuperuserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productFetchAllForSuperuser>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductFetchAllForSuperuserQueryOptions(areaId,userRead,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Dashboard
 */
export const productDashboard = (
    params: ProductDashboardParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ProductDashbordRead[]>(
      {url: `/api/v0.1/product/dashbord/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getProductDashboardQueryKey = (params?: ProductDashboardParams,) => {
    return [`/api/v0.1/product/dashbord/`, ...(params ? [params]: [])] as const;
    }

    
export const getProductDashboardInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof productDashboard>>>, TError = HTTPValidationError>(params: ProductDashboardParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductDashboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productDashboard>>> = ({ signal }) => productDashboard(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductDashboardInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof productDashboard>>>
export type ProductDashboardInfiniteQueryError = HTTPValidationError


export function useProductDashboardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productDashboard>>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productDashboard>>,
          TError,
          Awaited<ReturnType<typeof productDashboard>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductDashboardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productDashboard>>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productDashboard>>,
          TError,
          Awaited<ReturnType<typeof productDashboard>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductDashboardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productDashboard>>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Dashboard
 */

export function useProductDashboardInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productDashboard>>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductDashboardInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getProductDashboardQueryOptions = <TData = Awaited<ReturnType<typeof productDashboard>>, TError = HTTPValidationError>(params: ProductDashboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductDashboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productDashboard>>> = ({ signal }) => productDashboard(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof productDashboard>>>
export type ProductDashboardQueryError = HTTPValidationError


export function useProductDashboard<TData = Awaited<ReturnType<typeof productDashboard>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productDashboard>>,
          TError,
          Awaited<ReturnType<typeof productDashboard>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductDashboard<TData = Awaited<ReturnType<typeof productDashboard>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productDashboard>>,
          TError,
          Awaited<ReturnType<typeof productDashboard>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductDashboard<TData = Awaited<ReturnType<typeof productDashboard>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Dashboard
 */

export function useProductDashboard<TData = Awaited<ReturnType<typeof productDashboard>>, TError = HTTPValidationError>(
 params: ProductDashboardParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productDashboard>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductDashboardQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Price History
 */
export const productPriceHistory = (
    productId: string,
    params: ProductPriceHistoryParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<PriceHistoryRead[]>(
      {url: `/api/v0.1/product/price-history/${productId}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getProductPriceHistoryQueryKey = (productId?: string,
    params?: ProductPriceHistoryParams,) => {
    return [`/api/v0.1/product/price-history/${productId}`, ...(params ? [params]: [])] as const;
    }

    
export const getProductPriceHistoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof productPriceHistory>>>, TError = HTTPValidationError>(productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductPriceHistoryQueryKey(productId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productPriceHistory>>> = ({ signal }) => productPriceHistory(productId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductPriceHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof productPriceHistory>>>
export type ProductPriceHistoryInfiniteQueryError = HTTPValidationError


export function useProductPriceHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productPriceHistory>>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productPriceHistory>>,
          TError,
          Awaited<ReturnType<typeof productPriceHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductPriceHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productPriceHistory>>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productPriceHistory>>,
          TError,
          Awaited<ReturnType<typeof productPriceHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductPriceHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productPriceHistory>>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Price History
 */

export function useProductPriceHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof productPriceHistory>>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductPriceHistoryInfiniteQueryOptions(productId,params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getProductPriceHistoryQueryOptions = <TData = Awaited<ReturnType<typeof productPriceHistory>>, TError = HTTPValidationError>(productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductPriceHistoryQueryKey(productId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productPriceHistory>>> = ({ signal }) => productPriceHistory(productId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductPriceHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof productPriceHistory>>>
export type ProductPriceHistoryQueryError = HTTPValidationError


export function useProductPriceHistory<TData = Awaited<ReturnType<typeof productPriceHistory>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productPriceHistory>>,
          TError,
          Awaited<ReturnType<typeof productPriceHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductPriceHistory<TData = Awaited<ReturnType<typeof productPriceHistory>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productPriceHistory>>,
          TError,
          Awaited<ReturnType<typeof productPriceHistory>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductPriceHistory<TData = Awaited<ReturnType<typeof productPriceHistory>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Price History
 */

export function useProductPriceHistory<TData = Awaited<ReturnType<typeof productPriceHistory>>, TError = HTTPValidationError>(
 productId: string,
    params: ProductPriceHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productPriceHistory>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductPriceHistoryQueryOptions(productId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



